/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: anish_sk
 * Time: 2020-07-08 22:55:15
**/
#include<bits/stdc++.h>
#include<iomanip>
#include <ext/pb_ds/assoc_container.hpp> //required
#include <ext/pb_ds/tree_policy.hpp> //required
#include <queue>
#include<stdlib.h>
#include<stdio.h>
using namespace __gnu_pbds; //required
#define ll long long
#define ull unsigned ll
#define ld long double
#define pb push_back
#define mp make_pair
#define f first
#define s second
#define mul(x,y) ((ll)(x)*(y))%mod
#define tr(c,i) for(auto i = (c).begin(); i != (c).end(); i++)
#define forn(i, n)    for(int i = 0; i < n; i++)
#define FOR(i, x, y)  for(size_t i=size_t(x); i<size_t(y); i++)
#define ROF(i, x, y)  for(size_t i=size_t(x-1); i>=size_t(y); i--)
#define all(x) (x).begin(), (x).end()
using namespace std;
int clz(unsigned long long N) {
    return N ? 64 - __builtin_clzll(N) : -INFINITY;
}
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
unordered_map<long long, int, custom_hash> safe_map;
gp_hash_table<long long, int, custom_hash> safe_hash_table;
template<typename T>
ostream& operator<<(ostream& os, const pair<T,T> &p){
    os<<"["<<p.first<<", "<<p.second<<" ]";
    return os ;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v)
{
    os << "[";
    for (int i = 0; i < v.size(); ++i) {
        os << v[i];
        if (i != v.size() - 1)
            os << ", ";
    }
    os << "]\n";
    return os;
}
template <typename T>
istream& operator>>(istream& os, vector<T>& v)
{
    //int temp;
    for (unsigned int i = 0; i < v.size(); ++i) {
        os>>v[i];
    }
    return os;
}
template <typename T>
void o1(vector<T> &v){
    for(auto i: v) cout<<i<<" ";
    cout<<"\n";
}
//template<typename T>
void google(int cas){
    cout<<"Case #"<<cas<<": ";
}
#define vi vector<int>
#define vvi vector<vi>
#define ii pair<int, int>
#define vii vector<ii>
#define vll vector<ll>
#define vvl vector<vll>
ll gcd(ll a, ll b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}
void make_set(ll v, vll &parent, vll &size) {
    parent[v] = v;
    size[v] = 1;
}
ll find_set(ll v, vll &parent) {
    if (v == parent[v])
        return v;
    return parent[v] = find_set(parent[v],parent);
}
void union_sets(ll a, ll b,vll &parent, vll &size) {
    a = find_set(a,parent);
    b = find_set(b,parent);
    if (a != b) {
        if (size[a] < size[b])
            swap(a, b);
        parent[b] = a;
        size[a] += size[b];
    }
}
void dfsvisit(vvl &adj,vll &visited, ll v, vll &col){
    visited[v]=1;
    for(auto i: adj[v]){
        if(!visited[i]){
        col[i] = 1 - col[v];
        dfsvisit(adj, visited, i, col);
        }
    }
}
ll MPOW( ll a, ll b, ll m) { if(b==0) return 1; ll x=MPOW(a,b/2,m); x=(x*x)%m; if(b%2==1) x=(x*a)%m; return x;}
ll MINV( ll a, ll m) { return MPOW(a,m-2,m);}
template <typename T> using ordered_set =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
inline T ceil(T a, T b){
    return ((a+b-1)/b);
}
void dfs(vector<vll> &adj,ll u, ll v, vll &depth, vll &count){
    count[u]=1;
    for(auto i : adj[u]){
        if(i==v) continue;
        depth[i]=depth[u]+1;
        dfs(adj, i, u, depth, count);
        count[u]+=count[i];
    }
} 
vector<vector<ll>> primes;
vector<vector<ll>> facts;
void init_prime(ll size=1e6+1)
{
	primes.resize(size);
 
	for(ll i=2;i<size;i++)
	{
		if(primes[i].size()==0)
		{
			for(ll j=i;j<size;j+=i)
			primes[j].push_back(i);
		}
	}
}
 
void init_facts(ll size=2e5+1)
{
	facts.resize(size);
 
	for(ll i=1;i<size;i++)
	{
		for(ll j=i;j<size;j+=i)
		facts[j].push_back(i);
	}
}
ll p =1e9+7;
int main()
{
    ios_base::sync_with_stdio(0);
    cout.tie(NULL);
    cin.tie(NULL);
    int t=1;
    //cin>>t;
    while(t--){
        ll n; cin>>n; vvl x(n, vll(n,0)), y(n, vll(n,0)); 
        forn(i,n){
            forn(j,n){
                cin>>x[i][j]>>y[i][j];
                if(x[i][j]!=-1) {x[i][j] --; y[i][j] --;}
            }
        }
        vector< vector<char> > a(n, vector<char>(n,'0')); 
        vvl visited(n, vll(n,-1)), deg(n, vll(n,0));
        forn(i,n){
            forn(j,n){
                if(x[i][j] == -1 and a[i][j] == '0'){
                    //x[i][j]=1001;
                    ll n1 = 0, n2=0, n3=0, n4=0;
                    bool f = 0;
                    if(i<n-1){
                        if(x[i+1][j] == -1){
                            deg[i][j] += 1;
                            n1+=1;
                            a[i][j]='D';
                            a[i+1][j]='U';
                            f=1;
                            //x[i+1][j]=1001;
                        }
                    }
                    if(f) continue;
                    if(i>0){
                        if(x[i-1][j] == -1){
                            deg[i][j] += 1;
                            n2+=1;
                            a[i][j]='U';
                            a[i-1][j]='D';
                            //cout<<i<<" "<<j<<" "<<x[i-1][j]<<"\n";
                            f=1;
                            //x[i-1][j]=1001;
                        }
                    }
                    if(f) continue;
                    if(j<n-1){
                        if(x[i][j+1] == -1){
                            deg[i][j] += 1;
                            n3+=1;
                            a[i][j]='R';
                            a[i][j+1]='L';
                            f=1;
                            //x[i][j+1]=1001;
                        }
                    }
                    if(f) continue;
                    if(j>0){
                        if(x[i][j-1] == -1){
                            deg[i][j] += 1;
                            n4+=1;
                            a[i][j]='L';
                            a[i][j-1]='R';
                            f=1;
                            //x[i][j-1]=1001;
                        }
                    }
                    //if(n4 == 1 and n2 == 1){
                    //    a[i][j] = 'U';
                    //}
                    //if(n1 == 1 and n4 == 1){
                    //    a[i][j] = 'L';
                    //}
                    //if(n1 == 1 and n3 == 1){
                    //    a[i][j] = 'D';
                    //}
                    //if(n3 == 1 and n2 == 1){
                    //    a[i][j] = 'R';
                    //}
                    //if(n1 == 1 and n2 == 1){
                    //    if(a[i-1][j] == 'D') a[i][j] = 'D';
                    //    else a[i][j] = 'U';
                    //}
                    //if(n4 == 1 and n3 == 1){
                    //    if(a[i][j-1] == 'R') a[i][j] = 'R';
                    //    else a[i][j] = 'L';
                    //}

                }
                else deg[i][j] = -1;
            }
        }
        bool flag = 0;
        //forn(i,n) forn(j,n) if(deg[i][j] != 2 and deg[i][j]!=-1) flag = 1;
        if(flag){
            cout<<"INVALID\n";
        }
        else{
            forn(i,n){
                forn(j,n){
                    if(x[i][j] == i and y[i][j] == j){
                        //cout<<i<<" "<<j<<"\n";
                        a[i][j] = 'X';
                        visited[i][j]=1;
                        queue<pair<ll,ll>> q;
                        q.push({i,j});
                        while(q.size()){
                            pair<ll,ll> u = q.front(); q.pop();
                            if(u.f < n-1){
                                if(x[u.f+1][u.s] == i and y[u.f+1][u.s] == j){
                                    if(a[u.f+1][u.s] == '0')
                                    {q.push({u.f+1,u.s});
                                    a[u.f+1][u.s]='U';}
                                }
                            }
                            if(u.f > 0){
                                if(x[u.f-1][u.s] == i and y[u.f-1][u.s] == j){
                                    if(a[u.f-1][u.s] == '0')
                                    {q.push({u.f-1,u.s});
                                    a[u.f-1][u.s]='D';}
                                }
                            }
                            if(u.s < n-1){
                                if(x[u.f][u.s+1] == i and y[u.f][u.s+1] == j){
                                    if(a[u.f][u.s+1] == '0')
                                    {q.push({u.f,u.s+1});
                                    a[u.f][u.s+1]='L';}
                                }
                            }
                            if(u.s > 0){
                                if(x[u.f][u.s-1] == i and y[u.f][u.s-1] == j){
                                    if(a[u.f][u.s-1] == '0')
                                    {q.push({u.f,u.s-1});
                                    a[u.f][u.s-1]='R';}
                                }
                            }
                        }
                    }
                }
            }
            forn(i,n) forn(j,n) if(a[i][j] == '0') flag = 1;
            if(flag) cout<<"INVALID\n";
            else{
                cout<<"VALID\n";
                forn(i,n){
                    forn(j,n){
                        cout<<a[i][j];
                    }
                    cout<<"\n";
                }
            }
        }

    }
    return 0;
}
